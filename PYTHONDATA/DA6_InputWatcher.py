#Developed by James Booth M68153 for Microchip Technology 2022 #
#Github repo: https://github.com/jboothMCHP/OEE_DASHBOARD.git #
#The purpose of this architecture is to provide a complete solution for data extraction, wrangling and archiving data into MCHP SQL Servers via an ETL pipeline #
#ETL order is given at the top of the code beinging with 'PL' and increasing sequentially #
#Information is displayed via the 'OEE Dashboard' a Django based web app which pulls data from a csv file which generates up to date graphs via the plotly chart studio API #
#OEE Dashboard can be viewed at http://http://10.205.40.60/ #
#Historic information can be viewed in SSRS report at http://reporting.ax2012.microchip.com/reports/ #
#For scalability purposes code is duplicated for new machines (e.g., 'DA5','DA6' etc)#
#Program launch via cmd terminal: cd C:\vs_code\OEE_DASHBOARD\PYTHONDATA | python DA5_watcherWrapper.py #
#Server launch using port 80 (must be enabled on host PC): cd C:\vs_code\OEE_DASHBOARD\PYTHONDATA | python manage.py runserver 0.0.0.0:80 #
#Data is generated by the BESI Datacon Evos daily. Machine statistics export mode = Daily, Hour = 8, Delete machine statistics after export = On#
#The above means that data is recorded a the machine level daily and restarts its log on the 8th hour of everyday i.e. 8AM. #
#Therefore the data gathered on day 2 represents the OEE performance of day 1# 

##############################################################################################################################################################################

#PL02 for OEE Dashboard #
#The second stage of the pipeline PL02 is triggered when the using the same mechanic as ramFilterWatcher.py #
#The program uses the watchdog observers and events functions as before. The filepath to observe is defined in the path variable #
#When a new file is detected within the path directory a trigger is called to run the dataclean function (PL03) #



from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from DA6_dataClean import run_Data_Clean

def run_inputWatcher():

    print('Running inputWatcher.py')

    def run_Data_Clean_Trigger(path):
        print(f'Running dataClean on {path}')
        run_Data_Clean(path)



    class JamesEventHandler(FileSystemEventHandler):
    #Only interested in created events, so we only need to implement this method
        def on_created(self, event):
    #There's no guarantee that the file will be good since it's user input
    #Hence, we protect with a try-except block
            try:
                if event.is_directory == False:
                    print(f'Running DataCean Trigger on {path}')
                    run_Data_Clean_Trigger(event.src_path)
                    # print('True')
                    # print(event)
            except BaseException as err:
                print(err)


    
    path = 'P:\\OEE_Dashboard\\DA6\\Raw_Data_Input'
    #Create a new instance of our custom handler
    event_handler = JamesEventHandler()
    #Create a new watchdog observer
    observer = Observer()
    #Tell the observer to watch a 'path' recursively and use the 'event_handler'
    observer.schedule(event_handler, path, recursive=True)
    #Start the observer
    observer.start()
    return observer