#Developed by James Booth M68153 for Microchip Technology 2022 #
#Github repo: https://github.com/jboothMCHP/OEE_DASHBOARD.git #
#The purpose of this architecture is to provide a complete solution for data extraction, wrangling and archiving data into MCHP SQL Servers via an ETL pipeline #
#ETL order is given at the top of the code beinging with 'PL' and increasing sequentially #
#Information is displayed via the 'OEE Dashboard' a Django based web app which pulls data from a csv file which generates up to date graphs via the plotly chart studio API #
#OEE Dashboard can be viewed at http://http://10.205.40.60/ #
#Historic information can be viewed in SSRS report at http://reporting.ax2012.microchip.com/reports/ #
#For scalability purposes code is duplicated for new machines (e.g., 'DA5','DA6' etc)#
#Program launch via cmd terminal: cd C:\vs_code\OEE_DASHBOARD\PYTHONDATA | python DA5_watcherWrapper.py #
#Server launch using port 80 (must be enabled on host PC): cd C:\vs_code\OEE_DASHBOARD\PYTHONDATA | python manage.py runserver 0.0.0.0:80 #
#Data is generated by the BESI Datacon Evos daily. Machine statistics export mode = Daily, Hour = 8, Delete machine statistics after export = On#
#The above means that data is recorded a the machine level daily and restarts its log on the 8th hour of everyday i.e. 8AM. #
#Therefore the data gathered on day 2 represents the OEE performance of day 1# 

##############################################################################################################################################################################

#PL04 



from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from DA5_lineCounter import run_line_counter

def run_cleanedDataWatcher():

    print('Running cleanedDataWatcher.py')

    def run_line_counter_Trigger(path):
        print(f'Running lineCounter on {path}')
        run_line_counter(path)



    class JamesEventHandler(FileSystemEventHandler):
    # We're only interested in created events, so we only need to implement this method
        def on_created(self, event):
    # In general, there's no guarantee that the file will be good since it's user input
    # Hence, we protect ourselves with a try-except block
            try:
                if event.is_directory == False:
                    run_line_counter_Trigger(event.src_path)
                    # print('True')
                    # print(event)
            except BaseException as err:
                print(err)


    
    path = 'P:\\OEE_Dashboard\\DA5\\Cleaned_Data_Output'
    # We create a new instance of our custom handler
    event_handler = JamesEventHandler()
    # We create a new watchdog observer
    observer = Observer()
    # We tell the observer to watch a 'path' recursively and use the 'event_handler'
    observer.schedule(event_handler, path, recursive=True)
    # We start the observer
    observer.start()
    return observer